<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - shader [Monjori]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            color: #ffffff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            font-weight: bold;

            background-color: #000000;
            margin: 0px;
            overflow: hidden;
        }

        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 5px;
        }

        a {

            color: #ffffff;
        }
    </style>
</head>

<body>

    <div id="container"></div>
    <div id="info">
        <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> - shader demo. featuring
        <a href="http://www.pouet.net/prod.php?which=52761" target="_blank" rel="noopener">Monjori by Mic</a>
    </div>

    <script src="three.min.js"></script>
    <script src="Detector.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">

        varying vec3 p;
        varying float dn;
        const float G = 4.0;
        const float c = 2.0;
        
        void main()	{
            dn = (c*dot(position.xy, position.xy) + 1.0);
            float z = -G/dn;

            p = vec3(position.xy, z);
            
            gl_Position = projectionMatrix * viewMatrix * vec4(p, 1.0);
        }

    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">

        const float withBands = 0.005;
        // const float distanceBands = 0.07;
        const float distanceBands = 0.2;

        const float G = 4.0;
        const float c = 2.0;
        const vec2 CM = vec2(0.0, 0.0);
        
        const vec3 light = normalize(vec3(2, 0, -6));
        const float ambient = 0.1;
        const float diffuse = 0.8;
        const float specularComponent = 0.2;
        const vec3 specularColor = vec3(1.0, 1.0, 1.0);
        const vec3 colorMesh = vec3(0.016, 0.2235, 0.2392);
        const vec3 colorLine = vec3(0.3490, 0.8784, 0.91761);
        
        varying vec3 p;
        varying float dn;

        uniform float time;

        void main() {
            vec2 pos = vec2(p.xy);
            
            vec3 n = normalize(vec3(
                -2.0*c*G*p.x/dn/dn, 
                -2.0*c*G*p.y/dn/dn,
                1.0
            ));


            float ldx = p.x - distanceBands * floor(p.x/distanceBands);
            float ldy = p.y - distanceBands * floor(p.y/distanceBands);
            
            /*
            float d = 0.1;
            float qx = max(0.0, abs(1.0 - 2.0/distanceBands*ldx) - 0.5);
            float qy = max(0.0, abs(1.0 - 2.0/distanceBands*ldy) - 0.5);
            */

            float a = 16.5;
            float t = distanceBands;
            float qx = min(1.0, max(0.0, 2.0*a/t*(abs(mod(p.x, t) - t/2.0) - t/4.0) - 15.0/2.0));
            float qy = min(1.0, max(0.0, 2.0*a/t*(abs(mod(p.y, t) - t/2.0) - t/4.0) - 15.0/2.0));
            float q = min(1.0, qx + qy);

            vec3 pigment = q*colorLine + (1.0-q)*colorMesh;
            //vec3 pigment = p.x - distanceBands * floor(p.x/distanceBands) < withBands || p.y - distanceBands * floor(p.y/distanceBands) < withBands ? colorMesh : colorLine; 
            
            vec3 L = -light;
            vec3 R = 2.0 * dot(L, n) - L;
            vec3 V = normalize(cameraPosition - p.xyz);
            float dRV = max(dot(R, V), 0.0);
            vec3 specular = specularComponent * pow(dRV, 3.0) * specularColor;
            vec3 color = (ambient + diffuse*dot(L, n)) * pigment + specular;
            // vec3 color = cameraPosition;

            gl_FragColor = vec4(color, 1.0 );
            // gl_FragColor = vec4(dRV, dRV, dRV, 1.0 );
            // gl_FragColor = vec4(n.x, n.x, n.x, 1.0 );
            // gl_FragColor = vec4(q * vec3(1.0), 1.0 );
        }

    </script>

    <script>

        if (!Detector.webgl) Detector.addGetWebGLMessage();

        var container;

        var camera, scene, renderer;

        var uniforms;

        init();
        animate();

        function init() {

            container = document.getElementById('container');

            var width = window.innerWidth;
            var height = window.innerHeight;
            // camera = new THREE.OrthographicCamera(- 1, 1, 1, - 1, 0, 1);
            camera = new THREE.PerspectiveCamera(45, height/width, 0.1, 1000);
            camera.position.set(0, 1, 3);
            camera.up.set(0, 0, 1);
            camera.lookAt(new THREE.Vector3(0,0,-2));
            camera.updateProjectionMatrix();
            console.log('camera', camera);

            scene = new THREE.Scene();

            // scene.add(camera);

            var geometry = new THREE.PlaneBufferGeometry(2, 2, 1000, 1000);

            uniforms = {
                time: { value: 1.0 }
            };

            var material = new THREE.ShaderMaterial({

                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent

            });

            var mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            renderer = new THREE.WebGLRenderer();
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);

            onWindowResize();

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize(event) {

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        //

        function animate(timestamp) {

            requestAnimationFrame(animate);

            uniforms.time.value = timestamp / 1000;

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>